Search for `[blank]` for parts that are not finished.

The application is decomposed into 3 modules:

1. Model: handles data representation, data logic, e.g.:
    1. Classes to represent the game board, pieces, and nodes on the game board
    2. a function to assign a piece to a node on the board
2. View: displays the graphical user interface, e.g.:
    1. display an empty game board at the start of a new game
    2. display pieces on the board
3. Controller: handles user input, and accesses both view and model, e.g.:
    1. listeners are assigned to view to receive mouse click
    2. buttons with listener to clear the board

Highest level of Uses Relationship:


#Model
Under Model module, there are several classes we created to fully represent the data structures and logics.

##MainModel.java
MainModel is the top level class in Model. It acts like a parent class for all the other classes in Model. MainModel will access all other classes under Model. This is the only class that can be accessed by Controller. If there were changes made to Model, we only need to review the parts in Controller where only MainModel is used. Therefore the program is easy to adapt for change.

###*Uses*
- **GameBoard.java**
- **Player.java**

###*Interface (MIS)*
- **MainModel(): MainModel**  
Constructs a new MainModel object. Will call newGame().
- **getBoard(): GameBoard**  
Returns the GameBoard object of current MainModel.
- **getCurrentPlayer(): Player**  
Returns the current Player object of current MainModel.
- **newGame(): void**  
Initialize the MainModel objects. Will be called in the constructor.

###*Implementation (MID)*
####*Uses*
None

####*Variables*
- **currentPlayer: int**  
Stores an integer, 0 or 1, that indicates the current player.
- **gameBoard: GameBoard**  
Stores the GameBoard object for the current game board.
- **players: Player[]**  
An array that holds the two players of the game.

####*Access Programs*
- **MainModel(): MainModel**  
Constructs a new MainModel object. Will call newGame().
- **getBoard(): GameBoard**  
Returns the GameBoard object, gameBoard, of the MainModel object.
- **getCurrentPlayer(): Player**  
Returns the current Player object, Player[currentPlayer], of the MainModel object.
- **newGame(): void**  
Initialize the MainModel objects. It will create and initialize a new GameBoard object, gameBoard and two new Player objects.


##DIRECTION.java
It is a class of Enum type. It is used in Node.java to represent the relationship between nodes on a game board (see Node.java).

###*Uses*
None


###*Interface (MIS)*
None

###*Implementation (MID)*
**UP**  
Represent the up direction.

**DOWN**  
Represent the down direction.

**LEFT**  
Represent the left direction.

**RIGHT**  
Represent the right direction.


##Player.java
The Player class represent one player of the game. It has a bench and a variable to represent the number pieces the player has. The bench is a stack used to store the pieces that has not been placed on the game board. Everytime a piece is placed, it will be first be popped out of the bench stack. When the length of the bench is 0, it indicates the end of Phase I. The variable that represents the number of pieces the player has will help to check the winning state.

###*Uses*
- **Piece.java**

###*Interface (MIS)*
- **Player(): Player**  
  Creates a new Player object.

- **getPiece(): Piece**  
  Get an unplaced piece form the player to be placed on the game board.

###*Implementation (MID)*
####*Variables*
- **bench: Piece[]**  
This is a stack used to store the pieces that have not been placed on the board.
- **numOfPieces:int**  
This is a variable that represent 

####*Assess programes*
- **Player(ID: int): Player**  
It will create sixes pieces
- **getPiece(): Piece**

**getNumOfPieces(): int**  


##Piece.java
This class represent the pieces that each player has in the game.

###*Uses*
None

###*Interface (MIS)*
- **Piece(player: Player): Piece**
  Construct a new Piece object, and sets its onwer
- **getOnwer(): Player**
  Returns a Player object, the owner of the piece.

###*Implementation (MID)*
####*Variables*
- belongsTo: Player  
  It represent the owner of the Piece. It is set by the constructer.

####*Assess programes*
- **Piece(player: Player): Piece**  
  Construct a new Piece object, and sets its onwer
- **getOnwer(): Player**  
  Returns the value of `belongsTo`, a Player object, the owner of the piece.


##GameBoard
This class contains information about the game board. It contains information about all the nodes on the board, and provides interface to manipulate each nodes on the board. It stores `Node` objects in an array, and each `Node` is represented by their index in the array.

###*Uses*
- **Node.java**

###*Interface (MIS)*
- **GameBoard(): GameBoard**  
  [blank]
- **setPiece(piece: Piece,node: Node)**  
  Sets a Piece object on a given Node object
- **movePiece(origin: Node,dest: Node)**  
  move a Piece from one Node object, `origin`, to the another one, `dest`
- **removePiece(piece: Piece)**  
  remove a Piece object, `piece`, from the game board.  
- **checkLegalMove(): Error**  
  Check if the game board contained any illegal move. Returns an Error object.
- **checkWin(player: Player): boolean**  
  Check if the given player, `player`, had won
   

###*Implementation (MID)*
####*Variables*
- **nodes: Node[]**
  An array of Node objects that contains all the nodes on the game board.

####*Assess programes*
- **GameBoard(): GameBoard**  
  [blank]
- **setPiece(piece: Piece,node: Node)**  
  Sets a Piece object on a given Node object. Use Node's method `setPiece` to achieve this.
- **movePiece(origin: Node,dest: Node)**  
  Move a Piece from one Node object, `origin`, to the another one, `dest`. First, get the piece from `origin` using `getPiece`, then set the piece to `dest` using `setPiece`. After that, remove the piece from `origin` node using `removePiece` 
- **removePiece(node: Node)**  
  Remove the piece placed `node` from the game board. Use the `removePiece` method from `Node`
- **checkLegalMove(): int**  
  Check if the game board contained any illegal move. Returns an Error object. Loop through all the nodes of the game board, *[blank]*
- **checkWin(): void**  
  Check if one player had won. Loop though all nodes on the game board, and chall `checkV()` and `checkH()` on each node.
- **checkV(node: Node): boolean**  
  Check the vertical connections of `node`. Use `Node`'s methode, `getNeighbor`, to check the `UP` and `DOWN` directions of the node recursively, i.e. check the `UP` and `DOWN` directions of it's neighbor's, and neighboor's neighbor, if it had any. Return true if all nodes on the vertical direction of the `node` is occupied with the same player's piece.
- **checkH(node: Node): boolean**  
  Check the horizontal connections of `node`. Use `Node`'s methode, `getNeighbor`, to check the `LEFT` and `RIGHT` directions of the node recursively, i.e. check the `LEFT` and `RIGHT ` directions of it's neighbor's, and neighboor's neighbor, if it had any. Return true if all nodes on the vertical direction of the `node` is occupied with the same player's piece.


##Node.java
This class represent each nodes on the game board. It contains information about the piece that may be placed on it. The nodes will be connected by each other. The neighers of the cell are being represented by an EnumMap of DIRECTION and Node. We have implemented Node in such way, instead of having a 2D array, is that, the game board of Six Men's Morris has different number of nodes on each row. It would be hard to use a 2D array to store the nodes, as there would be fake nodes created to take up spaces, and detecting 3 pieces in a row would be hard, too.

###*Interface (MIS)*
- **Node(): Node**  
  [blank]
- **getPiece(): Piece**  
  Return the `Piece` object that's being placed on the node. It returns `null` if the node has no piece.
- **removePiece(): void**  
  Remove the `Piece` object that's being placed on the node.
- **setPiece(piece: Piece): void**  
  Set the given piece, `piece`, on the node.
- **getNeighbor(dir: DIRECTION): Node**  
  Return the neighbor of the node on the given direction, `dir`. It returns `null` if there is no neighbor on that direction.
- **setNeighbors(neighbors: EnumMap<DIRECTION,Node>): void**  
  Set the neighbors of the node to `neighbors`

###*Implementation (MID)*
####*Variables*
- piece: Piece  
  Contains the piece that's being placed on the node. It's `null` if there's no piece.
- neighbors: EnumMap<DIRECTION, Node>  
  Contains the information about it's neighbors on all four directions.

####*Assess programes*
- **GameBoard(): GameBoard**  
  [blank]
- **getPiece(): Piece**  
  Return the field `piece`.
- **removePiece(): void**  
  Set the field `piece` to `null`.
- **setPiece(piece: Piece): void**  
  Set the field `this.piece` to `piece`.
- **getNeighbor(dir: DIRECTION): Node**  
  Use `neighbors.get(dir)` to get the node on given direction.
- **setNeighbors(EnumMap<DIRECTION,Node>): void**  
  Set field `this.neighbors` to `neighbors`


##Error.java
A class that contains error messages. Mostly the error messages are for illegal moves on the game board.

###*Uses*
None

###*Interface (MIS)*
- **Error(): Error**  
  [blank]
- **getMsg(ID: int): string**  
  Get the string message of a given message ID, `ID`.
  
###*Implementation (MID)*
####*Variables*
- **messages: string[]**  
  Contains all the error messages that may appear in the game.
  
####*Assess programes*
- **GameBoard(): GameBoard**  
  [blank]
- **getMsg(ID: int): string**  
  Return the `ID`'th element of the `message` array



#View
[blank] [I'm not sure what to write for view]

##MainView.java
[description][blank]

###*Interface (MIS)*
- **MainView(): MainView**  
  [blank]
  
  
###*Implementation (MID)*
####*Variables*
- controller: MainController  
  It contains the controller, `MainController`.
- colors: Color[]  


####*Assess programes*
- **MainView(): MainView**  
  [blank]
- getNode(x: int,y: int):int  

- draw(gameboard: GameBoard): void  



##NodeView.java
[description][blank]

###*Interface (MIS)*
- **NodeView(): NodeView**  
  [blank]
  
###*Implementation (MID)*
####*Variables*
####*Assess programes*
- **NodeView(): NodeView**  
  [blank]

##BoardView.java
[description][blank]

###*Interface (MIS)*
- **BoardView(): BoardView**  
  [blank]
  
###*Implementation (MID)*
####*Variables*
####*Assess programes*
- **BoardView(): BoardView**  
  [blank]

##PieceView.java
[description][blank]

###*Interface (MIS)*
- **PieceView(): PieceView**  
  [blank]
  
###*Implementation (MID)*
####*Variables*
####*Assess programes*
- **PieceView(): PieceView**  
  [blank]


#Controller

##MainController.java
[description][blank]

###*Interface (MIS)*
- **MainController(): MainController**  
  [blank]
  
###*Implementation (MID)*
####*Variables*
- **model:MainModel**  
  

####*Assess programes*
- **MainController(): MainController**  
  [blank]
- **setNode(node:int): void**  
  
- **onNewGame(): void**  
  
- **getModel(): MainModel**  
  
- **checkLegalMove(): int**  
  
- **checkWin(): void**  
  
