Search for `[blank]` for parts that are not finished.


#Design Overview

##Modules
The application is decomposed into 3 components:

1. Model: handles data representation, data logic, e.g.:
    1. Classes to represent the game board, pieces, and nodes on the game board
    2. a function to assign a piece to a node on the board
2. View: displays the graphical user interface, e.g.:
    1. display an empty game board at the start of a new game
    2. display pieces on the board
3. Controller: handles user input, and accesses both view and model, e.g.:
    1. listeners are assigned to view to receive mouse click
    2. buttons with listener to clear the board

Highest level of Uses Relationship:

##Justifications for MVC
Model-View-Controler (MVC) is a very popular design pattern used for computer applications implementing user interfaces. The advantages of MVC design paradigm are many:

1. Separation of Concerns
    - It providesan isolation of the application's presentation layer that displays the data in the user interface, from the way the data is actually processed. For example, in our project, if there needs to be a change for the underlying logic on the board, only Model part needs to be modified while the Controller and View can be left untouched.
3. Modularity
    - The way in which a system's components can be separated and recombined. Meaning that for a software, different components can be maintained separately without breaking the entire system. This allows separation of concerns to be implemented with little effort.
4. Expectancy for Change
    - This suggests that software should be able to support upgrades or changes on a small part without causing the entire system to break. Modules should communicate with each other on a very abstract level. They only deal with each other's inputs and outputs. With the MVC ideology, View will be updated by Model, and Model will be maintained by Controller. The internal logic within any of the modules can be changed without breaking other modules.

#Model
Under Model module, there are several classes we created to fully represent the data structures and logics.

##MainModel.java
MainModel is the top level class in Model. It acts like a parent class for all the other classes in Model. MainModel will access all other classes under Model. This is the only class that can be accessed by Controller. If there were changes made to Model, we only need to review the parts in Controller where only MainModel is used. Therefore the program is easy to adapt for change.

###*Uses*
- **GameBoard.java**
- **Player.java**

###*Interface (MIS)*
- **MainModel(): MainModel**  
Constructs a new MainModel object. Will call newGame().
- **getBoard(): GameBoard**  
Returns the GameBoard object of current MainModel.
- **getCurrentPlayer(): Player**  
Returns the current Player object of current MainModel.
- **newGame(): void**  
Initialize the MainModel objects. Will be called in the constructor.

###*Implementation (MID)*
####*Uses*
None

####*Variables*
- **currentPlayer: int**  
Stores an integer, 0 or 1, that indicates the current player.
- **gameBoard: GameBoard**  
Stores the GameBoard object for the current game board.
- **players: Player[]**  
An array that holds the two players of the game.

####*Access Programs*
- **MainModel(): MainModel**  
Constructs a new MainModel object. Will call newGame().
- **getBoard(): GameBoard**  
Returns the GameBoard object, gameBoard, of the MainModel object.
- **getCurrentPlayer(): Player**  
Returns the current Player object, Player[currentPlayer], of the MainModel object.
- **newGame(): void**  
Initialize the MainModel objects. It will create and initialize a new GameBoard object, gameBoard and two new Player objects.


##DIRECTION.java
It is a class of Enum type. It is used in Node.java to represent the relationship between nodes on a game board (see Node.java).

###*Uses*
None

###*Interface (MIS)*
None

###*Implementation (MID)*
- **UP**  
Represent the up direction.
- **DOWN**  
Represent the down direction.
- **LEFT**  
Represent the left direction.
- **RIGHT**  
Represent the right direction.


##Player.java
The Player class represent one player of the game. It has a bench and a variable to represent the number pieces the player has. The bench is a stack used to store the pieces that has not been placed on the game board. Everytime a piece is placed, it will be first be popped out of the bench stack. When the length of the bench is 0, it indicates the end of Phase I. The variable that represents the number of pieces the player has will help to check the winning state.

###*Uses*
- **Piece.java**

###*Interface (MIS)*
- **Player(): Player**  
  Creates a new Player object.

- **getPiece(): Piece**  
  Get an unplaced piece form the player to be placed on the game board.

###*Implementation (MID)*
####*Variables*
- **bench: Piece[]**  
This is a stack used to store the pieces that have not been placed on the board.
- **numOfPieces:int**  
This is a variable that represent 

####*Assess programes*
- **Player(ID: int): Player**  
It will create sixes pieces
- **getPiece(): Piece**

**getNumOfPieces(): int**  


##Piece.java
This class represent the pieces that each player has in the game.

###*Uses*
None

###*Interface (MIS)*
- **Piece(player: Player): Piece**
  Construct a new Piece object, and sets its onwer
- **getOnwer(): Player**
  Returns a Player object, the owner of the piece.

###*Implementation (MID)*
####*Variables*
- belongsTo: Player  
  It represent the owner of the Piece. It is set by the constructer.

####*Assess programes*
- **Piece(player: Player): Piece**  
  Construct a new Piece object, and sets its onwer
- **getOnwer(): Player**  
  Returns the value of `belongsTo`, a Player object, the owner of the piece.


##GameBoard
This class contains information about the game board. It contains information about all the nodes on the board, and provides interface to manipulate each nodes on the board. It stores `Node` objects in an array, and each `Node` is represented by their index in the array.

###*Uses*
- **Node.java**

###*Interface (MIS)*
- **GameBoard(): GameBoard**  
  [blank]
- **setPiece(piece: Piece,node: Node)**  
  Sets a Piece object on a given Node object
- **movePiece(origin: Node,dest: Node)**  
  move a Piece from one Node object, `origin`, to the another one, `dest`
- **removePiece(piece: Piece)**  
  remove a Piece object, `piece`, from the game board.  
- **checkLegalMove(): Error**  
  Check if the game board contained any illegal move. Returns an Error object.
- **checkWin(player: Player): boolean**  
  Check if the given player, `player`, had won
   

###*Implementation (MID)*
####*Variables*
- **nodes: Node[]**
  An array of Node objects that contains all the nodes on the game board.

####*Assess programes*
- **GameBoard(): GameBoard**  
  [blank]
- **setPiece(piece: Piece,node: Node)**  
  Sets a Piece object on a given Node object. Use Node's method `setPiece` to achieve this.
- **movePiece(origin: Node,dest: Node)**  
  Move a Piece from one Node object, `origin`, to the another one, `dest`. First, get the piece from `origin` using `getPiece`, then set the piece to `dest` using `setPiece`. After that, remove the piece from `origin` node using `removePiece` 
- **removePiece(node: Node)**  
  Remove the piece placed `node` from the game board. Use the `removePiece` method from `Node`
- **checkLegalMove(): int**  
  Check if the game board contained any illegal move. Returns an Error object. Loop through all the nodes of the game board, *[blank]*
- **checkWin(): void**  
  Check if one player had won. Loop though all nodes on the game board, and chall `checkV()` and `checkH()` on each node.
- **checkV(node: Node): boolean**  
  Check the vertical connections of `node`. Use `Node`'s methode, `getNeighbor`, to check the `UP` and `DOWN` directions of the node recursively, i.e. check the `UP` and `DOWN` directions of it's neighbor's, and neighboor's neighbor, if it had any. Return true if all nodes on the vertical direction of the `node` is occupied with the same player's piece.
- **checkH(node: Node): boolean**  
  Check the horizontal connections of `node`. Use `Node`'s methode, `getNeighbor`, to check the `LEFT` and `RIGHT` directions of the node recursively, i.e. check the `LEFT` and `RIGHT ` directions of it's neighbor's, and neighboor's neighbor, if it had any. Return true if all nodes on the vertical direction of the `node` is occupied with the same player's piece.


##Node.java
This class represent each nodes on the game board. It contains information about the piece that may be placed on it. The nodes will be connected by each other. The neighers of the cell are being represented by an EnumMap of DIRECTION and Node. We have implemented Node in such way, instead of having a 2D array, is that, the game board of Six Men's Morris has different number of nodes on each row. It would be hard to use a 2D array to store the nodes, as there would be fake nodes created to take up spaces, and detecting 3 pieces in a row would be hard, too.

###*Interface (MIS)*
- **Node(): Node**  
  [blank]
- **getPiece(): Piece**  
  Return the `Piece` object that's being placed on the node. It returns `null` if the node has no piece.
- **removePiece(): void**  
  Remove the `Piece` object that's being placed on the node.
- **setPiece(piece: Piece): void**  
  Set the given piece, `piece`, on the node.
- **getNeighbor(dir: DIRECTION): Node**  
  Return the neighbor of the node on the given direction, `dir`. It returns `null` if there is no neighbor on that direction.
- **setNeighbors(neighbors: EnumMap<DIRECTION,Node>): void**  
  Set the neighbors of the node to `neighbors`

###*Implementation (MID)*
####*Variables*
- piece: Piece  
  Contains the piece that's being placed on the node. It's `null` if there's no piece.
- neighbors: EnumMap<DIRECTION, Node>  
  Contains the information about it's neighbors on all four directions.

####*Assess programes*
- **GameBoard(): GameBoard**  
  [blank]
- **getPiece(): Piece**  
  Return the field `piece`.
- **removePiece(): void**  
  Set the field `piece` to `null`.
- **setPiece(piece: Piece): void**  
  Set the field `this.piece` to `piece`.
- **getNeighbor(dir: DIRECTION): Node**  
  Use `neighbors.get(dir)` to get the node on given direction.
- **setNeighbors(EnumMap<DIRECTION,Node>): void**  
  Set field `this.neighbors` to `neighbors`


##Error.java
A class that contains error messages. Mostly the error messages are for illegal moves on the game board.

###*Uses*
None

###*Interface (MIS)*
- **Error(): Error**  
  [blank]
- **getMsg(ID: int): string**  
  Get the string message of a given message ID, `ID`.
  
###*Implementation (MID)*
####*Variables*
- **messages: string[]**  
  Contains all the error messages that may appear in the game.
  
####*Assess programes*
- **GameBoard(): GameBoard**  
  [blank]
- **getMsg(ID: int): string**  
  Return the `ID`'th element of the `message` array



#View
[blank] [I'm not sure what to write for view]

##MainView.java
[description][blank]

###*Interface (MIS)*
- **MainView(): MainView**  
  [blank]
  
  
###*Implementation (MID)*
####*Variables*
- controller: MainController  
  It contains the controller, `MainController`.
- colors: Color[]  


####*Assess programes*
- **MainView(): MainView**  
  [blank]
- getNode(x: int,y: int):int  

- draw(gameboard: GameBoard): void  



##NodeView.java
[description][blank]

###*Interface (MIS)*
- **NodeView(): NodeView**  
  [blank]
  
###*Implementation (MID)*
####*Variables*
####*Assess programes*
- **NodeView(): NodeView**  
  [blank]

##BoardView.java
[description][blank]

###*Interface (MIS)*
- **BoardView(): BoardView**  
  [blank]
  
###*Implementation (MID)*
####*Variables*
####*Assess programes*
- **BoardView(): BoardView**  
  [blank]

##PieceView.java
[description][blank]

###*Interface (MIS)*
- **PieceView(): PieceView**  
  [blank]
  
###*Implementation (MID)*
####*Variables*
####*Assess programes*
- **PieceView(): PieceView**  
  [blank]


#Controller

##MainController.java
[description][blank]

###*Interface (MIS)*
- **MainController(): MainController**  
  [blank]
  
###*Implementation (MID)*
####*Variables*
- **model:MainModel**  
  

####*Assess programes*
- **MainController(): MainController**  
  [blank]
- **setNode(node:int): void**  
  
- **onNewGame(): void**  
  
- **getModel(): MainModel**  
  
- **checkLegalMove(): int**  
  
- **checkWin(): void**  


 
#Traceback
*[blank]

|Requirement | Module|
|---|---|
|Set up a game board | GameField.java, Model.java
|Game board include two different kind of discs | GameField.java, Player.java, Piece.java
|Discs are placed on the side of board | GameField.java, Model.java
|User is able to start a new game | GameView.java*
|User is able to choose a colour of disc | GameView.java
|User is able to place disc on the board | GameView.java, Model.java, GameField.java
|User is able to indicate the end of phase | GameView.java*
|System can analyze whether the current state is possible or not | GameField.java, Node.java
|Errors will be highlighted on the screen | GameView.java, Model.java


#Internal Review
The DIRECTION enum class was abrogated during the implementation of the Model in favour of accomodating N-Men's Morris where N is any valid morris number. A valid morris number N is any integer N such that N >= 6 and N mod 3 = 0. The following classes were affected;
- GameField.java
- Game.java


#Design Decisions
The Model was built to accomodate any future changes in board architecture and board rules. The current implementation supports rules for N-Men's Morris for any valid integer N. The linked Node board architecture was abandoned in favour of increasing the implementation's responsiveness to change in the future.

#Internal Review
The DIRECTION enum class was abrogated during the implementation of the Model in favour of accomodating N-Men's Morris where N is any valid morris number. A valid morris number N is any integer N such that N >= 6 and N mod 3 = 0.  


#Design Decisions
The Model was built to accomodate any future changes in board architecture and board rules. The current implementation supports rules for N-Men's Morris for any valid integer N. The linked Node board architecture was abandoned in favour of increasing the implementation's responsiveness to change in the future.

#Test Report

Test Cases:

**Symbol Definition**
- N = Valid Node
- FN = Full Valid Node 
- EN = Empty Valid Node (i.e. the node is not assigned a player piece)
- IEN = Inalid Empty Node (i.e. the node exists and is not assigned a player piece)
- IFN = Invalid Full Node (i.e. will not exists) 

**Test Cases Rule Implementation for Morris Number 6.**

1. set piece to NE : true : passed
2. set piece to NF : true : passed
3. set piece to INE : false : passed
4. set piece to INF : false : passed
5. move piece from NF to NE : true : passed
6. move piece from NE to NF : false : passed
7. move piece from NF to NF : false : passed
8. move piece from NF to INE : false : passed
9. move piece from NF to INE : false : passed
10. move piece from NE to INF : false : passed
11. move piece from NF to INF : false : passed
12. move piece from INF to NE : false : passed
13. move piece from INF to INE : false : passed
14. move piece from INE to INF : false : passed
15. move piece from INF to INF : false : passed

**Test Cases for Board Logistics.**

1. remove piece from full player stack : returns Piece : passed
1. remove piece from stack with 1 Piece: returns Piece : passed
1. remove piece from empty stack : returns null : passed

**View Functionality**

The user-view interaction was tested informally through various trails.
